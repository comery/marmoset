
## General information of Marmoset genome assembly


## rough alignment and illustration of two allele assembly


all syntenic plot generated by nucmer program with input of repeat-masked genome, then graphed by mummerplot program.

```MUMmer-3.23/mummerplot``` or you can use [```flexidot ```](https://github.com/molbio-dresden/flexidot).

## Heterozygsity rate, sequencing error and polishing error

## detect heterozygsity site between two alleles

Mummer aligner gives a series of coordinative alignments of two alleles, the snp can be easily be retrieved from alignment base to base. However, to evaluate the accuracy and sequencing and polishing errors, we also conduct GATK and Samtools+bcftools variant calling pipeline to detect SNP from 10X genomics shotgun reads.

Notes:

- note1: The most fellowing bioinformatics processes are repeated for each pair of homologous chromosomes. By default, $a stands for chromosome ID, like Chr1, Chr2, and so on.

- note2: All software we used are described well and all scripts (being mentioned as bin/*) are deploied on Github website. you can find here: https://github.com/comery/marmoset

### step 1, mummer alignment

~~~~~~~~~~bash
nucmer -maxmatch -l 100 -c 500 -p $a mat_$a.fa pat_$a.fa
dnadiff -d $a.delta -p $a.diff
mv $a.diff.snps $a.diff.var
python3 bin/split_snp_indel.py $a.diff.var $a.diff
~~~~~~~~~~
this step will get $a.delta, $a.diff.1delta, $a.diff.1coords, $a.diff.var, $a.diff.snp, $a.diff.indel

### step 2, 10x mapping
The below file "sample.list" is a basename list containing fastq files. this step is to map, sort, and do MarkDuplicates and index bam files.

~~~~~~~~~~bash
ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
bwa="~/local/bin/bwa"
data="xxx/marmoset/DATA/10X_clean"
samtools="xxx/samtools-1.8/bin/samtools"
gatk="xxx/gatk-4.1.4.1/gatk"
cat ../sample.list|while read a
do
	[ -d $a ] || mkdir $a
	cd $a
	outdir=`pwd`
	echo "$bwa mem -t 10  $ref $data/${a}_1.fq.gz $data/${a}_2.fq.gz | $samtools view -Sb - > $outdir/${a}.bam && echo \"** bwa mapping done **\"
$samtools sort -@ 10 -m 4G -O bam -o $outdir/${a}.sorted.bam $outdir/${a}.bam && echo \"** BAM sort done\"
$gatk MarkDuplicates -I $outdir/${a}.sorted.bam -O $outdir/${a}.sorted.markdup.bam -M $outdir/${a}.sorted.markdup_metrics.txt && echo \"** markdup done **\"
$samtools index $outdir/${a}.sorted.markdup.bam && echo \"** index done **\" " >$a.bwa.sh
	sh $a.bwa.sh
	cd ..
done
~~~~~~~~~~
split whole genome mapping bam into subfiles by chrs and remove non-unique mapping results.

~~~~~~~~~~bash
samtools view  -h -q 1 -F 12 -F 256 maternal.merge.sorted.bam |grep -v 'XA:Z' | grep -v 'SA:Z' | samtools view -b - >maternal.merge.sorted.uniq.bam

#samtools index maternal.merge.sorted.uniq.bam
cat list|grep -v '^#' |while read a
do
	[ -d $a  ] || mkdir $a
	samtools view -h maternal.merge.sorted.uniq.bam mat_$a |awk '$1~/^@/ || $7=="=" {print}'|samtools view -bS - >$a/$a.bam
done
~~~~~~~~~~

### step 3, GATK

~~~~~bash
#### prepare index
ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
gatk="xxx/gatk-4.1.4.1/gatk"
samtools="xxx/samtools-1.8/bin/samtools"
bcftools="xxx/bcftools-1.8/bin/bcftools"
#0 check ref's index fai
wkdir=`pwd`
if [ -e $ref.fai ]
then
	echo "fasta index fai of reference is fine!"
else
	cd ${ref%/*}
	$samtools faidx $ref
	cd $wkdir
fi

# check dict of genome for gatk
if [ -e ${ref%%.fa}.dict ]
then
	echo "fasta index dict of reference is fine!"
else
	cd ${ref%/*}
	$gatk CreateSequenceDictionary -R $ref
	cd $wkdir
fi

#### call snp chr by chr
cat list|grep -v '^#' |while read a
do
	cd $a
	echo "# add sample tag to bam file
$samtools addreplacerg  -r '@RG\tID:foo\tPL:illumina\tSM:OFFSP' -o $a.addRG.bam $a.bam
# 1, generate gvcf file
$gatk HaplotypeCaller \\
	-R $ref \\
	--emit-ref-confidence GVCF \\
	-I $a.addRG.bam \\
	--native-pair-hmm-threads 10 \\
	-O $a.g.vcf && echo \"** gvcf done **\"

# 2, call snp
$gatk GenotypeGVCFs \\
	-R $ref \\
	-V $a.g.vcf \\
	-O $a.vcf && echo \"** vcf done **\" " >$a.gatk.sh
	sh $a.gatk.sh
	cd ..
done
~~~~~


### step 4, samtools + bcftools

~~~~~~~~~~bash
cat list|grep -v '^#' |while read a
do
	cd $a
	echo "# samtools + bcftools
$samtools mpileup -g -f $ref  -o $a.bcf $a.addRG.bam
$bcftools call -v -m -O z -o $a.sambcf.vcf.gz $a.bcf" >$a.sambcf.sh
	#sel-qsub evo 1g 1 $a.sambcf.sh
	cd ..
done
~~~~~~~~~~

### step 5, generate all potential snp list (union set of mummer || (GATK && Sambcf)) from three approaches

there are some files required before combine

- $a.pileup, which is generated by :
	
	~~~~~~~~~~bash
	$ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
	samtools mpileup -AB -f $ref -d 1000 $a.bam > $a.pileup
	~~~~~~~~~~
- $a.diff.1coords, this file can be found in nucmer align process.

~~~~~~~~~~bash
cat list |while read a
do 
	cd $a
	echo "perl bin/compare.snp.diff.pl $a.diff.snp $a.snp.vcf.gz $a.sambcf.vcf.gz $a $a.pileup $a.diff.1coords" >$a.work.sh
	sel-qsub evo 20g 1 $a.work.sh
	cd ..
done

this step will got $a.compared.tab.
~~~~~~~~~~


### Assess sequencing and polishing error

#### How to detect errors?

The genotype called form 10X data will be the standard to judge whether it is an SNP or not because we know that NGS data has the lowest sequencing error rate.  The genotype calling method is in a sample way - looking the depth distribution of each site, e.g. A(20), T(0), C(0), G(0) is the typical homozygous site whereas A(20), T(15), C(0), G(0) is the typical heterozygous site, and for other ambiguous situations, necessary filtering will take over the following process.

#### How to call genotype?

pi value is calculated by formula:
```
pi = 2*($nA*$nT+$nA*$nC+$nA*$nG+$nT*$nC+$nT*$nG+$nC*$nG)/(($ndepth)*($ndepth-1))
```
where nA, nT, nC, nG are depth of A, T, C, G respectively, and ndepth is the total depth of this site.

I my sorry to post the code here.

```python
def call_haplotype(base_dis, ty=None):
    bases = {'A': int(base_dis[0]),
             'T': int(base_dis[1]),
             'G': int(base_dis[2]),
             'C': int(base_dis[3])}
    pi = float(base_dis[4])
    sorted_bases = sorted(bases, key=lambda k: bases[k], reverse=True)
    hap1 = sorted_bases[0]
    hap2 = sorted_bases[1]
    hap3 = sorted_bases[2]
    gt = {}
    if pi == 0:
        ##this is a homozygous site, bases[hap2] == 0
        return (hap1, bases[hap1], hap1, bases[hap1])
    elif ty == 'tenx':
        if pi <= 0.15: # this is a homozygous pattern
            if bases[hap2] >= 5 and bases[hap1] / bases[hap2] < 5:
                return False
            elif bases[hap2] >= 20:
                return (hap1, bases[hap1], hap2, bases[hap2])
            else:
                return (hap1, bases[hap1], hap1, bases[hap1]) #homozygous
        elif pi >= 0.4 and bases[hap3] >= 20:
            return False # what a mass!
        else:
            ## this is a heterozgyous pattern
            if bases[hap2] <= 3:
                return False
            else:
                return (hap1, bases[hap1], hap2, bases[hap2])
    else:
        return (hap1, bases[hap1], hap2, bases[hap2])
```

The polishing step conducted after pacbio corrected read assembly, so I can compare the genotype before polishing and after polishing to figure out what happened.

For each site, at first, I compare the 10x genotype and assembled genotype (base in the maternal genome and paternal genome), if they are matched, ok! this looks good, if not matched, for example, 10x genotype is A/T, assembly is A/G (mat/pat), so G is a mistake, then I go through paternal corrected pacbio read mapping result and paternal raw pacbio read mapping to see which step introduced this error. If raw read mapping and corrected mapping show this site is T (exist G but with lower depth), but assembly is G, ok I can say it is a polishing error. however, I would like to say that is an assigning error, not a polishing literally. If raw read mapping and corrected mapping show this site is G, so this may be a sequencing error because it's wrong form the very beginning.

### generate all evidence chain

there are some files required before generate evidence chain.

- $a.mat2mat.pb.cor.$a.pileup, which is generated from bam file of assigned maternal corrected pacbio reads mapping to maternal genome
- $a.mat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned maternal raw pacbio reads mapping to maternal genome
- $a.pat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned paternal corrected pacbio reads mapping to paternal genome
- $a.pat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned paternal raw pacbio reads mapping to paternal genome
- $a.rqpos.coords, which is coordinative positions of between maternal and paternal genome. it's from:

~~~~~bash
cat list|while read a
do
	cd $a
	MUMmer-3.23/show-aligns -r -w 100 $a.diff.1delta mat_$a pat_$a >$a.alns
	python3 bin/extract_pos_from_MummerAlns.py xxx/marmoset/2.genetic_divergency/SNP_INDEL/SNP_Mum_10X_Pacbio/$a/$a.potential.pos $a.alns $a
	cd ..
done
~~~~~

then let's start to combine all evidences

~~~~~bash
cat list|grep -v '^#' |while read a
do
    cd $a
    echo $a
    echo "python3 bin/select_pileup_from_comparedTab.py $a.pileup $a.compared.tab >$a.10x.compared.pileup
bin/Alignmentout_Sum.pl -in $a.10x.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.10x.compared
python3 bin/select_pileup_from_comparedTab.py mat2mat.pb.cor.$a.pileup $a.compared.tab >$a.mat2mat.pb.cor.compared.pileup
python3 bin/select_pileup_from_comparedTab.py mat2mat.pb.raw.$a.pileup $a.compared.tab >$a.mat2mat.pb.raw.compared.pileup
 extract pileup file by coords
python3 bin/select_Patpileup_from_coords.py pat2pat.pb.cor.$a.pileup $a.rqpos.coords >$a.pat2pat.pb.cor.compared.pileup
python3 bin/select_Patpileup_from_coords.py pat2pat.pb.raw.$a.pileup $a.rqpos.coords >$a.pat2pat.pb.raw.compared.pileup
bin/Alignmentout_Sum.pl -in $a.mat2mat.pb.cor.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.mat2mat.pb.cor.compared
bin/Alignmentout_Sum.pl -in $a.mat2mat.pb.raw.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.mat2mat.pb.raw.compared
bin/Alignmentout_Sum.pl -in $a.pat2pat.pb.cor.compared.pileup -type pileup -ref pat_$a.fa  -outpre $a.pat2pat.pb.cor.compared
bin/Alignmentout_Sum.pl -in $a.pat2pat.pb.raw.compared.pileup -type pileup -ref pat_$a.fa  -outpre $a.pat2pat.pb.raw.compared
python3 bin/join_5evidence.py $a.compared.tab $a.rqpos.coords $a.10x.compared.base.xls $a.mat2mat.pb.cor.compared.base.xls $a.mat2mat.pb.raw.compared.base.xls $a.pat2pat.pb.cor.compared.base.xls $a.pat2pat.pb.raw.compared.base.xls  > $a.5evidence.xls" >$a.work.sh
    #sel-qsub evo 0.1g 1 $a.work.sh
    sh $a.work.sh
    cd ..
done
~~~~~

### How to read all evidence tab

the $a.compared.tab format

~~~~~text
#CHROME	R_POS	R_REF	Q_POS	Q_REF	VAR_MUMMER	VAR_GATK	VAR_BCF	NOTE_GR	NOTE_DEP	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi
~~~~~


Feild 1-10: reference information and variants generated by different approach

- CHROME:     maternal reference chromosome
- R_POS:      position in maternal genome
- R_REF:      base in maternal genome
- Q_POS:      coordinative position in paternal genome
- Q_REF:      coordinative base in paternal genome
- VAR_MUMMER: SNP detected by Mummer
- VAR_GATK:   SNP detected by GATK
- VAR_BCF:    SNP detected by samtools + bcftools method
- NOTE_GR:    whether this site locates in grey region, which is not in maternal/paternal alignment
- NOTE_DEP:   10X read depth, if it small than 10, it will show "LOW"


Feild 11-18: 10x genomics read mapping to maternal genome

- Chr:       reference name
- Pos:       position in reference genome
- Depth:     total depth in this site
- A:         number of 'A' site of all mapped reads
- T:         number of 'T' site of all mapped reads
- G:         number of 'G' site of all mapped reads
- C:         number of 'C' site of all mapped reads
- Pi:        Pi necultide diversity value, calculated following the formula :

Feild 19-26: maternal assigned corrected pacbio reads mapping to maternal genome

Feild 27-34: maternal assigned raw pacbio reads mapping to maternal genome

Feild 35-42: paternal assigned corrected pacbio reads mapping to paternal genome

Feild 43-50: paternal assigned raw pacbio reads mapping to paternal genome

all format is same as feild 11-18



#### Some examples

- case1, no error

~~~text
mat_Chr21	8092609	A	8391768	C	C	C	C	.	.	mat_Chr21	8092609	25	15	0	0	10	0.5000	mat_Chr21	8092609	26	23	0	0	3	0.2123	mat_Chr21	8092609	26	26	0	0	0	0.0000	pat_Chr21	8391768	42	13	0	1	28	0.4704	pat_Chr21	8391768	44	10	0	0	34	0.3594
~~~

- case2, polishing error

~~~text
mat_Chr1	75110	T	103441	G	G	-	-	.	.	mat_Chr1	75110	31	0	31	0	0	0.0000	mat_Chr1	75110	31	0	31	0	0	0.0000	pat_Chr1	103441	10	0	9	1	0	0.2000	pat_polishing_err
~~~

- case3, sequencing error

~~~text
mat_Chr1	5674	C	344	C	-	A	A	.	.	mat_Chr1	5674	43	15	0	0	28	0.4651	mat_Chr1	5674	10	2	0	0	8	0.3556	pat_Chr1	344	3	0	0	0	3	0.0000	sequencing_err
~~~




