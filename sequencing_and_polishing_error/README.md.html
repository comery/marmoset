<meta charset="utf-8" emacsmode="-*- markdown -*-"> <link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/journal.css?">

# General information of Marmoset genome assembly


## rough alignment and illustration of two allele assembly

### original version of genome assembly
all syntenic plot generated by nucmer program with input of remasked genome, then graphed by mummerplot program

<!--more-->

|  |  |  |  |
| --- | --- | --- |
| ![Chr1](Chrs_Mummer/before_cruated_pngs/Chr1.masked.nucmer.png) | ![Chr2](Chrs_Mummer/before_cruated_pngs/Chr2.masked.nucmer.png) | ![Chr3](Chrs_Mummer/before_cruated_pngs/Chr3.masked.nucmer.png) |
| ![Chr4](Chrs_Mummer/before_cruated_pngs/Chr4.masked.nucmer.png) | ![Chr5](Chrs_Mummer/before_cruated_pngs/Chr5.masked.nucmer.png) | ![Chr6](Chrs_Mummer/before_cruated_pngs/Chr6.masked.nucmer.png) |
| ![Chr7](Chrs_Mummer/before_cruated_pngs/Chr7.masked.nucmer.png) | ![Chr8](Chrs_Mummer/before_cruated_pngs/Chr8.masked.nucmer.png) | ![Chr9](Chrs_Mummer/before_cruated_pngs/Chr9.masked.nucmer.png) |
| ![Chr10](Chrs_Mummer/before_cruated_pngs/Chr10.masked.nucmer.png) | ![Chr11](Chrs_Mummer/before_cruated_pngs/Chr11.masked.nucmer.png) | ![Chr12](Chrs_Mummer/before_cruated_pngs/Chr12.masked.nucmer.png) |
| ![Chr13](Chrs_Mummer/before_cruated_pngs/Chr13.masked.nucmer.png) | ![Chr14](Chrs_Mummer/before_cruated_pngs/Chr14.masked.nucmer.png) | ![Chr15](Chrs_Mummer/before_cruated_pngs/Chr15.masked.nucmer.png) |
| ![Chr16](Chrs_Mummer/before_cruated_pngs/Chr16.masked.nucmer.png) | ![Chr7](Chrs_Mummer/before_cruated_pngs/Chr17.masked.nucmer.png) | ![Chr18](Chrs_Mummer/before_cruated_pngs/Chr18.masked.nucmer.png) |
| ![Chr19](Chrs_Mummer/before_cruated_pngs/Chr19.masked.nucmer.png) | ![Chr20](Chrs_Mummer/before_cruated_pngs/Chr20.masked.nucmer.png) |![Chr21](Chrs_Mummer/before_cruated_pngs/Chr21.masked.nucmer.png) |
|![Chr22](Chrs_Mummer/before_cruated_pngs/Chr22.masked.nucmer.png) | | 



## corrected version: cruated chromosomes of Chr7, Chr9, and Chr22

|  |  |  |  
| --- | --- | --- |
| ![Chr7](Chrs_Mummer/after_cruated_pngs/Chr7.masked.nucmer.curated.png)|![Chr9](Chrs_Mummer/after_cruated_pngs/Chr9.masked.nucmer.curated.png) |![Chr22](Chrs_Mummer/after_cruated_pngs/Chr22.masked.nucmer.curated.png) |


## assembly statistic


# Heterozygsity rate, sequencing error and polishing error

## detect heterozygsity site between two alleles

mummer aligner gives a series of coordinative alignments of two alleles, the snp can be easily be retrieved from alignment base to base. However, to evaluate the accuracy and sequencing and polishing errors, we also conduct GATK and Samtools+bcftools variant calling pipeline to detect SNP from 10X genomics shotgun reads.

Notes:

- note1: The most fellowing bioinformatics processes are repeated for each pair of homologous chromosomes. By default, $a stands for chromosome ID, like Chr1, Chr2, and so on.

- note2: All software we used are described well and all scripts (being mentioned as bin/*) are deploied on Github website. you can find here: https://github.com/comery/marmoset_genetic_diversity

### step 1, mummer alignment

~~~~~~~~~~bash
nucmer -maxmatch -l 100 -c 500 -p $a mat_$a.fa pat_$a.fa
dnadiff -d $a.delta -p $a.diff
mv $a.diff.snps $a.diff.var
python3 bin/split_snp_indel.py $a.diff.var $a.diff
~~~~~~~~~~
this step will get $a.delta, $a.diff.1delta, $a.diff.1coords, $a.diff.var, $a.diff.snp, $a.diff.indel

### step 2, 10x mapping
The below file "sample.list" is a basename list containing fastq files. this step is to map, sort, and do MarkDuplicates and index bam files.

~~~~~~~~~~bash
ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
bwa="~/local/bin/bwa"
data="xxx/marmoset/DATA/10X_clean"
samtools="xxx/samtools-1.8/bin/samtools"
gatk="xxx/gatk-4.1.4.1/gatk"
cat ../sample.list|while read a
do
	[ -d $a ] || mkdir $a
	cd $a
	outdir=`pwd`
	echo "$bwa mem -t 10  $ref $data/${a}_1.fq.gz $data/${a}_2.fq.gz | $samtools view -Sb - > $outdir/${a}.bam && echo \"** bwa mapping done **\"
$samtools sort -@ 10 -m 4G -O bam -o $outdir/${a}.sorted.bam $outdir/${a}.bam && echo \"** BAM sort done\"
$gatk MarkDuplicates -I $outdir/${a}.sorted.bam -O $outdir/${a}.sorted.markdup.bam -M $outdir/${a}.sorted.markdup_metrics.txt && echo \"** markdup done **\"
$samtools index $outdir/${a}.sorted.markdup.bam && echo \"** index done **\" " >$a.bwa.sh
	sh $a.bwa.sh
	cd ..
done
~~~~~~~~~~
split whole genome mapping bam into subfiles by chrs and remove non-unique mapping results.

~~~~~~~~~~bash
samtools view  -h -q 1 -F 12 -F 256 maternal.merge.sorted.bam |grep -v 'XA:Z' | grep -v 'SA:Z' | samtools view -b - >maternal.merge.sorted.uniq.bam

#samtools index maternal.merge.sorted.uniq.bam
cat list|grep -v '^#' |while read a
do
	[ -d $a  ] || mkdir $a
	samtools view -h maternal.merge.sorted.uniq.bam mat_$a |awk '$1~/^@/ || $7=="=" {print}'|samtools view -bS - >$a/$a.bam
done
~~~~~~~~~~

### step 3, GATK

~~~~~bash
#### prepare index
ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
gatk="xxx/gatk-4.1.4.1/gatk"
samtools="xxx/samtools-1.8/bin/samtools"
bcftools="xxx/bcftools-1.8/bin/bcftools"
#0 check ref's index fai
wkdir=`pwd`
if [ -e $ref.fai ]
then
	echo "fasta index fai of reference is fine!"
else
	cd ${ref%/*}
	$samtools faidx $ref
	cd $wkdir
fi

# check dict of genome for gatk
if [ -e ${ref%%.fa}.dict ]
then
	echo "fasta index dict of reference is fine!"
else
	cd ${ref%/*}
	$gatk CreateSequenceDictionary -R $ref
	cd $wkdir
fi

#### call snp chr by chr
cat list|grep -v '^#' |while read a
do
	cd $a
	echo "# add sample tag to bam file
$samtools addreplacerg  -r '@RG\tID:foo\tPL:illumina\tSM:OFFSP' -o $a.addRG.bam $a.bam
#1 生成中间文件gvcf
$gatk HaplotypeCaller \\
	-R $ref \\
	--emit-ref-confidence GVCF \\
	-I $a.addRG.bam \\
	--native-pair-hmm-threads 10 \\
	-O $a.g.vcf && echo \"** gvcf done **\"

#2 通过gvcf检测变异
$gatk GenotypeGVCFs \\
	-R $ref \\
	-V $a.g.vcf \\
	-O $a.vcf && echo \"** vcf done **\" " >$a.gatk.sh
	sh $a.gatk.sh
	cd ..
done
~~~~~


### step 4, samtools + bcftools

~~~~~~~~~~bash
cat list|grep -v '^#' |while read a
do
	cd $a
	echo "# samtools + bcftools
$samtools mpileup -g -f $ref  -o $a.bcf $a.addRG.bam
$bcftools call -v -m -O z -o $a.sambcf.vcf.gz $a.bcf" >$a.sambcf.sh
	#sel-qsub evo 1g 1 $a.sambcf.sh
	cd ..
done
~~~~~~~~~~

### step 5, generate all potential snp list (union set of mummer || (GATK && Sambcf)) from three approaches

there are some files required before combine

- $a.pileup, which is generated by :
	
	~~~~~~~~~~bash
	$ref="xxx/marmoset/0.assembly/curated/mat.genome.curated.fa"
	samtools mpileup -AB -f $ref -d 1000 $a.bam > $a.pileup
	~~~~~~~~~~
- $a.diff.1coords, this file can be found in nucmer align process.

~~~~~~~~~~bash
cat list |while read a
do 
	cd $a
	echo "perl bin/compare.snp.diff.pl $a.diff.snp $a.snp.vcf.gz $a.sambcf.vcf.gz $a $a.pileup $a.diff.1coords" >$a.work.sh
	sel-qsub evo 20g 1 $a.work.sh
	cd ..
done

this step will got $a.compared.tab.
~~~~~~~~~~


## assess sequencing and polishing error

How to detect errors?

The genotype called form 10X data will be the standard to judge whether it is an SNP or not. the genotype calling method is in a sample way - looking the nucleotide distribution of each site, e.g. A(20), T(0), C(0), G(0) is the typical homozygous site whereas A(20), T(15), C(0), G(0) is the typical heterozygous site, and for other ambiguous situations, necessary filtering will take over the following process.

The polishing step conducted after pacbio corrected read assembly, so I can compare the genotype before polishing and after polishing to figure out what happened.

For each site, at first, I compare the 10x genotype and assembled genotype (base in the maternal genome and paternal genome), if they are matched, ok! this looks good, if not matched, for example, 10x genotype is A/T, assembly is A/G (mat/pat), so G is a mistake, then I go through paternal corrected pacbio read mapping result and paternal raw pacbio read mapping to see which step introduced this error. If raw read mapping and corrected mapping show this site is T (exist G but with lower depth), but assembly is G, ok I can say it is a polishing error. however, I would like to say that is an assigning error, not a polishing literally. If raw read mapping and corrected mapping show this site is G, so this may be a sequencing error because it's wrong form the very beginning.

### generate all evidence chain

there are some files required before generate evidence chain.

- $a.mat2mat.pb.cor.$a.pileup, which is generated from bam file of assigned maternal corrected pacbio reads mapping to maternal genome
- $a.mat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned maternal raw pacbio reads mapping to maternal genome
- $a.pat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned paternal corrected pacbio reads mapping to paternal genome
- $a.pat2mat.pb.raw.$a.pileup, which is generated from bam file of assigned paternal raw pacbio reads mapping to paternal genome
- $a.rqpos.coords, which is coordinative positions of between maternal and paternal genome. it's from:

~~~~~bash
cat list|while read a
do
	cd $a
	MUMmer-3.23/show-aligns -r -w 100 $a.diff.1delta mat_$a pat_$a >$a.alns
	python3 bin/extract_pos_from_MummerAlns.py xxx/marmoset/2.genetic_divergency/SNP_INDEL/SNP_Mum_10X_Pacbio/$a/$a.potential.pos $a.alns $a
	cd ..
done
~~~~~

then let's start to combine all evidences

~~~~~bash
cat list|grep -v '^#' |while read a
do
    cd $a
    echo $a
    echo "python3 bin/select_pileup_from_comparedTab.py $a.pileup $a.compared.tab >$a.10x.compared.pileup
bin/Alignmentout_Sum.pl -in $a.10x.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.10x.compared
python3 bin/select_pileup_from_comparedTab.py mat2mat.pb.cor.$a.pileup $a.compared.tab >$a.mat2mat.pb.cor.compared.pileup
python3 bin/select_pileup_from_comparedTab.py mat2mat.pb.raw.$a.pileup $a.compared.tab >$a.mat2mat.pb.raw.compared.pileup
 extract pileup file by coords
python3 bin/select_Patpileup_from_coords.py pat2pat.pb.cor.$a.pileup $a.rqpos.coords >$a.pat2pat.pb.cor.compared.pileup
python3 bin/select_Patpileup_from_coords.py pat2pat.pb.raw.$a.pileup $a.rqpos.coords >$a.pat2pat.pb.raw.compared.pileup
bin/Alignmentout_Sum.pl -in $a.mat2mat.pb.cor.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.mat2mat.pb.cor.compared
bin/Alignmentout_Sum.pl -in $a.mat2mat.pb.raw.compared.pileup -type pileup -ref mat_$a.fa  -outpre $a.mat2mat.pb.raw.compared
bin/Alignmentout_Sum.pl -in $a.pat2pat.pb.cor.compared.pileup -type pileup -ref pat_$a.fa  -outpre $a.pat2pat.pb.cor.compared
bin/Alignmentout_Sum.pl -in $a.pat2pat.pb.raw.compared.pileup -type pileup -ref pat_$a.fa  -outpre $a.pat2pat.pb.raw.compared
python3 bin/join_5evidence.py $a.compared.tab $a.rqpos.coords $a.10x.compared.base.xls $a.mat2mat.pb.cor.compared.base.xls $a.mat2mat.pb.raw.compared.base.xls $a.pat2pat.pb.cor.compared.base.xls $a.pat2pat.pb.raw.compared.base.xls  > $a.5evidence.xls" >$a.work.sh
    #sel-qsub evo 0.1g 1 $a.work.sh
    sh $a.work.sh
    cd ..
done
~~~~~

### How to read all evidence tab

the $a.compared.tab format

~~~~~text
#CHROME	R_POS	R_REF	Q_POS	Q_REF	VAR_MUMMER	VAR_GATK	VAR_BCF	NOTE_GR	NOTE_DEP	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi	Chr	Pos	Depth	A	T	G	C	Pi
~~~~~


Feild 1-10: reference information and variants generated by different approach

- CHROME:     maternal reference chromosome
- R_POS:      position in maternal genome
- R_REF:      base in maternal genome
- Q_POS:      coordinative position in paternal genome
- Q_REF:      coordinative base in paternal genome
- VAR_MUMMER: SNP detected by Mummer
- VAR_GATK:   SNP detected by GATK
- VAR_BCF:    SNP detected by samtools + bcftools method
- NOTE_GR:    whether this site locates in grey region, which is not in maternal/paternal alignment
- NOTE_DEP:   10X read depth, if it small than 10, it will show "LOW"


Feild 11-18: 10x genomics read mapping to maternal genome

- Chr:       reference name
- Pos:       position in reference genome
- Depth:     total depth in this site
- A:         number of 'A' site of all mapped reads
- T:         number of 'T' site of all mapped reads
- G:         number of 'G' site of all mapped reads
- C:         number of 'C' site of all mapped reads
- Pi:        Pi necultide diversity value, calculated following the formula :

Feild 19-26: maternal assigned corrected pacbio reads mapping to maternal genome

Feild 27-34: maternal assigned raw pacbio reads mapping to maternal genome

Feild 35-42: paternal assigned corrected pacbio reads mapping to paternal genome

Feild 43-50: paternal assigned raw pacbio reads mapping to paternal genome

all format is same as feild 11-18



#### Some examples

- case1, no error

~~~text
mat_Chr21	8092609	A	8391768	C	C	C	C	.	.	mat_Chr21	8092609	25	15	0	0	10	0.5000	mat_Chr21	8092609	26	23	0	0	3	0.2123	mat_Chr21	8092609	26	26	0	0	0	0.0000	pat_Chr21	8391768	42	13	0	1	28	0.4704	pat_Chr21	8391768	44	10	0	0	34	0.3594
~~~

- case2, polishing error

~~~text
mat_Chr1	75110	T	103441	G	G	-	-	.	.	mat_Chr1	75110	31	0	31	0	0	0.0000	mat_Chr1	75110	31	0	31	0	0	0.0000	pat_Chr1	103441	10	0	9	1	0	0.2000	pat_polishing_err
~~~

- case3, sequencing error

~~~text
mat_Chr1	5674	C	344	C	-	A	A	.	.	mat_Chr1	5674	43	15	0	0	28	0.4651	mat_Chr1	5674	10	2	0	0	8	0.3556	pat_Chr1	344	3	0	0	0	3	0.0000	sequencing_err
~~~





## snp validation
pre-experiment

for each plate, it contains 95 samples and 1 negative control

Plate 1, 
34 denovo mutations (mother) + 61 SNPs

Plate 2,
34 denovo mutations (father) + 61 SNPs

Plate 3,
34 denovo mutations (offspring) + 61 SNPs

Plate 4,
95 indel (<50 bp)

PCR + GEL
50 indel (>50 bp)

PCR + GEL
10 SV (CNVs)


## about primer design

randomly select 300 SNPs from snp result tab, and then design primer pair for each SNP site.
rank them primers by quality, and select top number 183.



# Indel

## how to detect indel between two alleles
indel result can be found in mummer directory, which generated by nucmer program:

~~~~~~~~~~bash
nucmer -maxmatch -l 100 -c 500 -p $a mat_$a.fa pat_$a.fa
dnadiff -d $a.delta -p $a.diff
mv $a.diff.snps $a.diff.var
python3 bin/split_snp_indel.py $a.diff.var $a.diff
~~~~~~~~~~

have a look at indel result:

~~~~~text
7270	T	.	1939	3	1939	218136636	216975769	1	1	mat_Chr1	pat_Chr1
8102	T	.	2770	1	2770	218136636	216975769	1	1	mat_Chr1	pat_Chr1
8103	G	.	2770	1	2770	218136636	216975769	1	1	mat_Chr1	pat_Chr1
~~~~~

it's one site in a line, not well to read, so convert it to one record in a line:

~~~~~~~~~~bash
python3 bin/indel_statistic_RefPos.py $a.diff.indel $a
~~~~~~~~~~

now look again:

~~~~~text
# S. means ref is string (> 1bp) and a deletion in query
#Chrom	R	type	subType	length	R_base	Q_base
Chr1.diff	7270	insert	T.	1	T	.
Chr1.diff	8102	delete	S.	2	TG	.
~~~~~

## filter indel base 10x read mapping
a large number of Indels are adjacent with repeative sequences. especially polynucleotides which
indicates that many Indels are probably false. So the validation using shotgun reads is very important.


## small indel (< 50 bp) and longer indel (>= 50 bp)


# SVs

## detect SVs

Structural variation was originally defined as insertions, deletions and inversions greater than 1 kb in size.

there are many algorithms and tools designed for detecting SVs based on NGS data, but very few for SV detection from whole genome alignment. in this study, we will employe svmu and SyRi, two developing programs to detect SV from Mummer alignment. After several round tests, I found that svmu only can detect CNVs and large Indels, whereas SyRi can get other SVs and duplications (CNVs) except INDELs. So, we will use these two methods and then select overlap result of them as confident results.


### run SyRi to detect SVs (INV, INVTR, TRANS)

current directory: xxx/marmoset/2.genetic_divergency/Alignment_nomask/Mummer_syri

The SyRI (Synteny and Rearrangement Identifier), a method to identify structural as well as sequence differences between two whole-genome assemblies. SyRI expects whole-genome alignments (WGA) as input and starts by searching for differences in the structures of the genomes. Afterwards, SyRI identifies local sequence differences within both the rearranged and the non-rearranged (syntenic) regions. SyRI annotates the coordinates of rearranged regions (i.e., breakpoints on both sides of a rearrangement in both genomes) providing a complete regional annotation of rearrangements. 

~~~~~bash
data="xxx/marmoset/2.genetic_divergency/Alignment_masked/Chrs"
cat list|while read a
do
	[ -d $a ] || mkdir $a
	cd $a
	echo "$software/MUMmer-3.23/nucmer --maxmatch -c 500 -b 500 -l 100 $data/$a/mat_$a.fa $data/$a/pat_$a.fa -p $a
$software/MUMmer-3.23/delta-filter -m -i 90 -l 100 $a.delta > $a.delta.filt
$software/MUMmer-3.23/show-coords -THrd $a.delta.filt > $a.delta.filt.coords
conda activate syri_env
export PATH=$software/MUMmer-3.23/:\$PATH
$software/syri-1.0/syri/bin/syri -c $a.delta.filt.coords -r $data/$a/mat_$a.fa -q $data/$a/pat_$a.fa -d $a.delta.filt" > $a.syri.sh
	sel-qsub evo 2g 1 $a.syri.sh
	cd ..
done
~~~~~


### run svmu to detect CNVs and large INDELs

SVMU (Structural Variants from MUmmer) attempts to identify comprehensive sequence variants via alignment of two contiguous genome assemblies. It combines the strengths of two powerful aligners MUMmer and LASTZ to annotate duplicates, large indels, inversions, small indels, SNPs from whole genome alignments.

1. Obtain the mummer and lastz alignments:

Note: Lastz output is not suit for this study, when I add lastz results into svmu input, there is nothing
coming to result, but when I add an empty lastz file, it worked.

mummer alignment delat file can get from above, but here we need do a filtering step.


2. run svmu:

current directory: xxx/marmoset/2.genetic_divergency/Alignment_nomask/svmu

~~~~~bash
dir="xxx/marmoset/2.genetic_divergency/Alignment_masked"
snp_mode="l"
cat list|grep -v '^#'|while read a
do
	[ -d $a ] || mkdir $a
	cd $a
	echo "$software/svmu-0.4-alpha/svmu $dir/Mummer_syri/$a/$a.delta.filt $dir/Chrs/$a/mat_$a.fa $dir/Chrs/$a/pat_$a.fa $snp_mode $dir/Lastz/$a/$a.lastz.txt $a " > $a.svmu.sh
	# sh  $a.svmu.sh
	cd ..
done
~~~~~


## verify SVs
The basic method to verify SVs is that finding the extend SV regions to both allele. what we expect is that SV region in reference can only be found in its pacbio reads, whereas not found in query pacbio reads.

![SV_validation](SVs/SV_validation.png)




<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>