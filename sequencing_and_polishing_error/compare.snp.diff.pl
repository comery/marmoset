#!/usr/bin/perl -w

my $Usage = qq/Usage:
	perl $0 <snp from Mummer> <vcf from gatk> <vcf from bcftools> <out prefix> <pileup> <*.1coords>
/;
die "$Usage" unless (@ARGV == 6);

my (%ref,%var1,%var2, %var3);
($ARGV[0] =~ /gz$/) ? open VA1,"gzip -dc $ARGV[0]|" : open VA1,"$ARGV[0]";
($ARGV[1] =~ /gz$/) ? open VA2,"gzip -dc $ARGV[1]|" : open VA2,"$ARGV[1]";
($ARGV[2] =~ /gz$/) ? open VA3,"gzip -dc $ARGV[2]|" : open VA3,"$ARGV[2]";

my $low_depth_cutoff = 10;

while(<VA1>) {
	chomp;
	next if (/^#/ or /\bINDEL/);
	my @a = split /\t/,$_;
	# mummer snp generated by dnadiff, not show-snp
	$ref{$a[10]}{$a[0]} = $a[1];
	$var1{$a[10]}{$a[0]} = $a[2];
}
close VA1;

while(<VA2>) {
	chomp;
	next if (/^#/ or /\bINDEL/);
	my @a = split /\t/,$_;
	$ref{$a[0]}{$a[1]} = $a[3];
	$var2{$a[0]}{$a[1]} = $a[4];
}
close VA2;

while(<VA3>) {
	chomp;
	next if (/^#/ or /\bINDEL/);
	my @a = split /\t/,$_;
	$ref{$a[0]}{$a[1]} = $a[3];
	$var3{$a[0]}{$a[1]} = $a[4];
}
close VA3;

open PI, "$ARGV[4]" or die "can not open pileup file!";
my (%bamref, %depth);
while(<PI>){
	chomp;
	#next if (/^#/);
	my ($chr, $pos, $base, $dep) = (split)[0,1,2,3];
	if (exists $ref{$chr}{$pos}) {
		$bamref{$pos} = $base;
		$depth{$pos} = $dep;
	}
}
close PI;

open CO, "$ARGV[5]" or die "can not open coords file!";
my %coords;
while(<CO>){
	chomp;
	my ($start, $end) = (split)[0,1];
	for(my $i= $start;$i <= $end;$i++){
		$coords{$i} = 1;
	}

}
close CO;

open OUT,">$ARGV[3].compared.tab";
open OUT1, ">$ARGV[3].compared.fil.tab";

print OUT "#CHROME\tPOS\tREF\tVAR_MUMMER\tVAR_GATK\tVAR_BCF\tNOTE_RG\tNOTE_DEP\n";
print OUT1 "#CHROME\tPOS\tREF\tVAR_MUMMER\tVAR_GATK\tVAR_BCF\n";
my ($union, $real_union, $intersec, $identical, $different, $mummer_unique, $gatk_unique);

$union = 0;
$real_union = 0;
$intersec = 0;
$identical = 0;
$different = 0;
$mummer_unique = 0;
$gatk_unique = 0;

my @all_chr = sort keys %ref;
foreach my $chr(@all_chr){
	my $f = $ref{$chr};
	my @sort_sites = sort{$a<=>$b} keys %$f;
	# union set  = (mummer || (GATK && Samtools))
	foreach my $loca(@sort_sites){
		my $var_mummer = ((exists $var1{$chr}{$loca}) ? $var1{$chr}{$loca} : "-");
		my $var_gatk = ((exists $var2{$chr}{$loca}) ? $var2{$chr}{$loca} : "-");
		my $var_bcf = ((exists $var3{$chr}{$loca}) ? $var3{$chr}{$loca} : "-");
		$union ++;
		# output each result of each software and compare them
		if ($var_gatk eq $var_bcf) {
			print OUT "$chr\t$loca\t$$f{$loca}\t$var_mummer\t$var_gatk\t$var_bcf\t";

			# add information of whether site in coords region, and whether has low depth
			my $note_mummer_region = ((exists $coords{$loca}) ? "." : "GR");
			#print "$loca\t$bamref{$loca}\t$ref{$chr}{$loca}\t$depth{$loca}\n";
			my $note_depth;
			if (exists $bamref{$loca}){
				$note_depth = (($bamref{$loca} eq $ref{$chr}{$loca} && $depth{$loca} >= $low_depth_cutoff) ? "." : "LOW");
			}else{
				$note_depth = "LOW"; # because this site doesn't exist in pileup file, low depth in most case.

			}

			print OUT "$note_mummer_region\t$note_depth\n";

			# output clean tab, that's a real union set
			if ($note_mummer_region eq '.' && $note_depth eq '.'){
				$real_union ++;
				print OUT1 "$chr\t$loca\t$$f{$loca}\t$var_mummer\t$var_gatk\t$var_bcf\n";

				$intersec ++ if (exists $var1{$chr}{$loca} && exists $var2{$chr}{$loca});
				if ($var_mummer eq $var_gatk){
					$identical ++;
				}elsif (($var_mummer eq "-") && ($var_gatk ne "-")){
					$gatk_unique ++;
				}elsif (($var_mummer ne "-") && ($var_gatk eq "-")){
					$mummer_unique ++;
				}else{
					$different ++;
				}
			}

		}

	}
}
close OUT;
close OUT1;


open LOG, ">$ARGV[3].compared.log";
print LOG "Union: $union\n";
print LOG "Filtered Union: $real_union\n";
print LOG "Intersection: $intersec\n";
print LOG "Identical: $identical\n";
print LOG "Different: $different\n";
print LOG "Mummer-1/10X-0: $mummer_unique\n";
print LOG "Mummer-0/10X-1: $gatk_unique\n";
close LOG;
